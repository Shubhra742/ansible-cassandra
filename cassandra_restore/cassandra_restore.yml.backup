---
- name: Cassandra Restore Automation
  hosts: cassandra_nodes
  become: yes
  vars_prompt:
    - name: local_snapshot_path
      prompt: "Enter LOCAL path to Backup Snapshot Directory (e.g. /home/user/backup_cassandra/node-<ip>/date/time)"
      private: no

    - name: remote_snapshot_base
      prompt: "Enter REMOTE directory where backup should be copied (e.g. /home/ubuntu/cassandra_backups)"
      private: no
      default: "/home/ubuntu/cassandra_backups"

    - name: vm_choice
      prompt: "Choose restoration scenario:\n1. Restoration on Different VM\n2. Restoration on Same VM\nEnter your choice (1 or 2)"
      private: no

    - name: restore_mode
      prompt: "Choose restoration mode (only for Different VM):\n1. Complete database restoration\n2. Selected keyspace restoration\nEnter your choice (1 or 2, or press Enter to skip)"
      private: no
      default: "1"

    - name: cassandra_ip
      prompt: "Enter Cassandra IP (e.g. 172.31.42.5)"
      private: no

    - name: cql_user
      prompt: "Enter Cassandra username"
      private: no

    - name: cql_pass
      prompt: "Enter Cassandra password"
      private: yes

    - name: replication_clause
      prompt: "Enter full keyspace replication clause (e.g., WITH replication = {'class': 'NetworkTopologyStrategy', 'dc1': '3'} AND durable_writes = true;)"
      private: no

    - name: orig_keyspace
      prompt: "Enter original keyspace name (only for Same VM scenario, or press Enter to skip)"
      private: no
      default: ""

    - name: orig_table
      prompt: "Enter original table name (only for Same VM scenario, or press Enter to skip)"
      private: no
      default: ""

    - name: new_keyspace
      prompt: "Enter NEW keyspace name (only for Same VM scenario, or press Enter to skip)"
      private: no
      default: ""

    - name: new_table
      prompt: "Enter NEW table name (only for Same VM scenario, or press Enter to skip)"
      private: no
      default: ""

    - name: selected_keyspace
      prompt: "Enter keyspace to restore (only for Selected keyspace mode, or press Enter to skip)"
      private: no
      default: ""

  vars:
    data_dir: "/var/lib/cassandra/data"
    cassandra_user: "cassandra"
    cassandra_group: "cassandra"
    log_dir: "/var/log/cassandra_restore_log"
    restore_script_path: "/tmp/cassandra_restore.sh"
    snapshot_path: "{{ remote_snapshot_base }}/{{ local_snapshot_path | basename }}"
    system_keyspaces:
      - "system"
      - "system_auth"
      - "system_distributed"
      - "system_schema"
      - "system_traces"

  tasks:
    - name: Check if local backup directory exists
      local_action:
        module: stat
        path: "{{ local_snapshot_path }}"
      register: local_backup
      become: no

    - name: Fail if local backup directory does not exist
      fail:
        msg: "Local backup directory {{ local_snapshot_path }} does not exist!"
      when: not local_backup.stat.exists

    - name: Create remote backup base directory
      file:
        path: "{{ remote_snapshot_base }}"
        state: directory
        owner: "{{ ansible_user }}"
        mode: '0755'

    - name: Copy backup from local to remote server
      synchronize:
        src: "{{ local_snapshot_path }}"
        dest: "{{ remote_snapshot_base }}/"
        delete: no
        recursive: yes
      register: backup_copy

    - name: Display backup copy status
      debug:
        msg: "Backup copied successfully to {{ snapshot_path }}"
      when: backup_copy.changed

    - name: Create log directory
      file:
        path: "{{ log_dir }}"
        state: directory
        owner: "{{ cassandra_user }}"
        group: "{{ cassandra_group }}"
        mode: '0755'

    - name: Copy restore script to remote host
      copy:
        content: |
          #!/bin/bash
          
          set -euo pipefail
          
          DATE=$(date +%Y%m%d)
          TIME=$(date +%H%M%S)
          LOG_DIR="{{ log_dir }}"
          LOG_FILE="$LOG_DIR/restore_${DATE}_${TIME}.log"
          exec > >(tee -a "$LOG_FILE") 2>&1
          
          DATA_DIR="{{ data_dir }}"
          CASSANDRA_USER="{{ cassandra_user }}"
          CASSANDRA_GROUP="{{ cassandra_group }}"
          SYSTEM_KS=({{ system_keyspaces | join(' ') }})
          
          SNAPSHOT_PATH="{{ snapshot_path }}"
          VM_CHOICE="{{ vm_choice }}"
          RESTORE_MODE="{{ restore_mode }}"
          CASSANDRA_IP="{{ cassandra_ip }}"
          CQL_USER="{{ cql_user }}"
          CQL_PASS="{{ cql_pass }}"
          REPLICATION_CLAUSE="{{ replication_clause }}"
          ORIG_KS="{{ orig_keyspace }}"
          ORIG_TBL="{{ orig_table }}"
          NEW_KS="{{ new_keyspace }}"
          NEW_TBL="{{ new_table }}"
          SEL_KS="{{ selected_keyspace }}"
          
          if [[ ! -d "$SNAPSHOT_PATH" ]]; then
              echo "Backup Snapshot Directory '$SNAPSHOT_PATH' does not exist."
              exit 1
          fi
          
          run_cql() {
              cqlsh "$CASSANDRA_IP" -u "$CQL_USER" -p "$CQL_PASS" -e "$1" 2>/tmp/cql_err.log || {
                  echo "Failed to connect to Cassandra or execute CQL."
                  cat /tmp/cql_err.log
                  exit 1
              }
          }
          
          restore_table() {
              local ORIG_KS="$1"
              local ORIG_TBL="$2"
              local NEW_KS="$3"
              local NEW_TBL="$4"
          
              echo "Creating keyspace $NEW_KS if not exists..."
              run_cql "CREATE KEYSPACE IF NOT EXISTS \"$NEW_KS\" $REPLICATION_CLAUSE"
          
              local SNAPSHOT_DIR=$(find "$SNAPSHOT_PATH/$ORIG_KS" -maxdepth 1 -type d -name "${ORIG_TBL}*" | head -n1)
              if [[ ! -d "$SNAPSHOT_DIR" ]]; then
                  echo "Backup Snapshot directory not found for $ORIG_KS/$ORIG_TBL"
                  return
              fi
          
              local SCHEMA_FILE="$SNAPSHOT_DIR/schema.cql"
              if [[ ! -f "$SCHEMA_FILE" ]]; then
                  echo "schema.cql missing for $ORIG_KS.$ORIG_TBL"
                  return
              fi
          
              local TMP_CQL="/tmp/create_${NEW_KS}_${NEW_TBL}.cql"
              awk '
                  BEGIN { skip=0 }
                  /^CREATE TABLE/ { skip=1; print; next }
                  /^\)/ && skip { print ");"; exit }
                  skip { print }
              ' "$SCHEMA_FILE" | sed "s/${ORIG_KS}\.${ORIG_TBL}/${NEW_KS}.${NEW_TBL}/g" > "$TMP_CQL"
          
              echo "Creating table $NEW_KS.$NEW_TBL..."
              cqlsh "$CASSANDRA_IP" -u "$CQL_USER" -p "$CQL_PASS" -f "$TMP_CQL" || {
                  echo "Failed to create table $NEW_KS.$NEW_TBL"
                  return
              }
          
              local NEW_TABLE_DIR=$(find "$DATA_DIR/$NEW_KS" -maxdepth 1 -type d -name "${NEW_TBL}-*")
              if [[ -z "$NEW_TABLE_DIR" ]]; then
                  echo "Could not locate new table dir for $NEW_KS.$NEW_TBL"
                  return
              fi
          
              echo "Copying SSTables..."
              cp -r "$SNAPSHOT_DIR"/* "$NEW_TABLE_DIR/"
              chown -R "$CASSANDRA_USER:$CASSANDRA_GROUP" "$DATA_DIR/$NEW_KS"
          
              echo "Running nodetool import..."
              nodetool import "$NEW_KS" "$NEW_TBL" "$NEW_TABLE_DIR" || {
                  echo "nodetool import failed for $NEW_KS.$NEW_TBL"
                  return
              }
          
              echo "Restored $NEW_KS.$NEW_TBL"
          }
          
          # =====================
          # Scenario 1: Different VM
          # =====================
          if [[ "$VM_CHOICE" == "1" ]]; then
              if [[ "$RESTORE_MODE" == "1" ]]; then
                  for ks_path in "$SNAPSHOT_PATH"/*; do
                      ks=$(basename "$ks_path")
                      if [[ " ${SYSTEM_KS[*]} " =~ " $ks " ]]; then
                          echo "Skipping system keyspace: $ks"
                          continue
                      fi
                      if [[ ! -d "$ks_path" ]]; then
                          echo "Skipping invalid directory: $ks_path"
                          continue
                      fi
                      echo "Restoring keyspace: $ks"
                      for tbl_path in "$ks_path"/*; do
                          tbl_dir=$(basename "$tbl_path")
                          tbl="${tbl_dir%%-*}"
                          restore_table "$ks" "$tbl" "$ks" "$tbl"
                      done
                  done
          
              elif [[ "$RESTORE_MODE" == "2" ]]; then
                  if [[ -z "$SEL_KS" ]]; then
                      echo "No keyspace specified for selected keyspace restoration!"
                      exit 1
                  fi
          
                  if [[ ! -d "$SNAPSHOT_PATH/$SEL_KS" ]]; then
                      echo "Keyspace $SEL_KS not found in snapshot path."
                      exit 1
                  fi
          
                  echo "Restoring keyspace: $SEL_KS"
                  for tbl_path in "$SNAPSHOT_PATH/$SEL_KS"/*; do
                      tbl_dir=$(basename "$tbl_path")
                      tbl="${tbl_dir%%-*}"
                      restore_table "$SEL_KS" "$tbl" "$SEL_KS" "$tbl"
                  done
              else
                  echo "Invalid restoration mode!"
                  exit 1
              fi
          
          # =====================
          # Scenario 2: Same VM
          # =====================
          elif [[ "$VM_CHOICE" == "2" ]]; then
              if [[ -z "$ORIG_KS" || -z "$ORIG_TBL" || -z "$NEW_KS" || -z "$NEW_TBL" ]]; then
                  echo "Missing parameters for Same VM restoration!"
                  exit 1
              fi
          
              if [[ ! -d "$SNAPSHOT_PATH/$ORIG_KS" ]]; then
                  echo "Keyspace $ORIG_KS not found in snapshot path."
                  exit 1
              fi
          
              restore_table "$ORIG_KS" "$ORIG_TBL" "$NEW_KS" "$NEW_TBL"
          
          else
              echo "Invalid VM option!"
              exit 1
          fi
          
          echo "Restore completed successfully!"
        dest: "{{ restore_script_path }}"
        mode: '0755'
        owner: root
        group: root

    - name: Verify snapshot directory exists on remote host
      stat:
        path: "{{ snapshot_path }}"
      register: snapshot_dir

    - name: Fail if snapshot directory does not exist on remote
      fail:
        msg: "Snapshot directory {{ snapshot_path }} does not exist on remote host after copy!"
      when: not snapshot_dir.stat.exists

    - name: Execute restore script
      shell: "{{ restore_script_path }}"
      register: restore_output
      async: 7200
      poll: 10

    - name: Display restore output
      debug:
        var: restore_output.stdout_lines

    - name: Check for restore errors
      fail:
        msg: "Restore failed! Check the logs at {{ log_dir }}"
      when: restore_output.rc != 0

    - name: Display log file location
      debug:
        msg: "Restore logs are available at {{ log_dir }}/restore_*.log"

    - name: Cleanup restore script
      file:
        path: "{{ restore_script_path }}"
        state: absent
      when: restore_output.rc == 0
